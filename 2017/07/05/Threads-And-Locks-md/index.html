<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="在 java 并发编程中，线程和锁永远是最重要的概念。语言规范虽然是规范描述，但是其中也有非常多的知识和最佳实践是值得学习的，相信这篇文章还是可以给很多读者提供学习参考的。 本文主要是翻译 + 解释 Oracle《The Java Language Specification, Java SE 8 Edition》的第17章《Threads and Locks》，原文大概30页pdf，我加入了很多">
<meta property="og:type" content="article">
<meta property="og:title" content="深入分析 java 8 编程语言规范：Threads and Locks">
<meta property="og:url" content="http://yoursite.com/2017/07/05/Threads-And-Locks-md/index.html">
<meta property="og:site_name" content="Java熊">
<meta property="og:description" content="在 java 并发编程中，线程和锁永远是最重要的概念。语言规范虽然是规范描述，但是其中也有非常多的知识和最佳实践是值得学习的，相信这篇文章还是可以给很多读者提供学习参考的。 本文主要是翻译 + 解释 Oracle《The Java Language Specification, Java SE 8 Edition》的第17章《Threads and Locks》，原文大概30页pdf，我加入了很多">
<meta property="og:image" content="http://yoursite.com/images/shang.jpg">
<meta property="og:updated_time" content="2017-07-20T07:32:34.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="深入分析 java 8 编程语言规范：Threads and Locks">
<meta name="twitter:description" content="在 java 并发编程中，线程和锁永远是最重要的概念。语言规范虽然是规范描述，但是其中也有非常多的知识和最佳实践是值得学习的，相信这篇文章还是可以给很多读者提供学习参考的。 本文主要是翻译 + 解释 Oracle《The Java Language Specification, Java SE 8 Edition》的第17章《Threads and Locks》，原文大概30页pdf，我加入了很多">
<meta name="twitter:image" content="http://yoursite.com/images/shang.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/07/05/Threads-And-Locks-md/"/>





  <title>深入分析 java 8 编程语言规范：Threads and Locks | Java熊</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?4b184c55e2404e189b57f75ab8ac7158";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>











  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Java熊</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/05/Threads-And-Locks-md/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hong Jie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Java熊">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">深入分析 java 8 编程语言规范：Threads and Locks</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-05T00:00:00+08:00">
                2017-07-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/concurrency/" itemprop="url" rel="index">
                    <span itemprop="name">concurrency</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/07/05/Threads-And-Locks-md/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/07/05/Threads-And-Locks-md/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>在 java 并发编程中，线程和锁永远是最重要的概念。语言规范虽然是规范描述，但是其中也有非常多的知识和最佳实践是值得学习的，相信这篇文章还是可以给很多读者提供学习参考的。</p>
<p>本文主要是<strong>翻译 + 解释</strong> Oracle《<a href="https://docs.oracle.com/javase/specs/index.html" target="_blank" rel="external">The Java Language Specification, Java SE 8 Edition</a>》的第17章《<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html" target="_blank" rel="external">Threads and Locks</a>》，原文大概30页pdf，我加入了很多自己的理解，希望能帮大家把规范看懂，并且从中得到很多你一直想要知道但是还不知道的知识。</p>
<p>笔者能力有限，只能尽心尽力，我花了大量的时间在这篇文章上，希望能真正帮助到一部分人。能力不能及之处，我已经在文中标记出来了。</p>
<p>建议分 3 部分阅读。</p>
<ol>
<li>将 17.1、17.2、17.3 一起阅读，这里关于线程中的 wait、notify、中断有很多的知识；</li>
<li>17.4 的内存模型比较长，重排序和 happens-before 关系是重点；</li>
<li>剩下的 final、字分裂、double和long的非原子问题，这些都是相对独立的 topic。</li>
</ol>
<a id="more"></a>
<div style="text-align: center; font-size: 24px; font-weight: bold">Chapter 17. Threads and Locks</div>

<!-- toc -->
<ul>
<li><a href="#前言">前言</a></li>
<li><a href="#171-同步synchronization">17.1 同步（synchronization）</a></li>
<li><a href="#172-等待集合-和-唤醒wait-sets-and-notification">17.2 等待集合 和 唤醒（Wait Sets and Notification）</a><ul>
<li><a href="#1721-等待-wait">17.2.1 等待 （Wait）</a></li>
<li><a href="#1722-通知notification">17.2.2 通知（Notification）</a></li>
<li><a href="#1723-中断interruptions">17.2.3 中断（Interruptions）</a></li>
<li><a href="#1724-等待-通知和中断-的交互interactions-of-waits-notification-and-interruption">17.2.4 等待、通知和中断 的交互（Interactions of Waits, Notification, and Interruption）</a></li>
</ul>
</li>
<li><a href="#173-休眠和礼让sleep-and-yield">17.3. 休眠和礼让（Sleep and Yield）</a></li>
<li><a href="#174-内存模型memory-model">17.4 内存模型（Memory Model）</a><ul>
<li><a href="#1741-共享变量shared-variables">17.4.1. 共享变量（Shared Variables）</a></li>
<li><a href="#1742-操作actions">17.4.2. 操作（Actions）</a></li>
<li><a href="#1743-程序和程序顺序programs-and-program-order">17.4.3. 程序和程序顺序（Programs and Program Order）</a></li>
<li><a href="#1744-同步顺序synchronization-order">17.4.4. 同步顺序（Synchronization Order）</a></li>
<li><a href="#1745-happens-before顺序happens-before-order">17.4.5. Happens-before顺序（Happens-before Order）</a></li>
<li><a href="#1746-executions">17.4.6. Executions</a></li>
<li><a href="#1747-well-formed-executions">17.4.7. Well-Formed Executions</a></li>
<li><a href="#1748-executions-and-causality-requirements">17.4.8. Executions and Causality Requirements</a></li>
<li><a href="#1749-observable-behavior-and-nonterminating-executions">17.4.9. Observable Behavior and Nonterminating Executions</a></li>
</ul>
</li>
<li><a href="#175-final-属性的语义final-field-semantics">17.5. final 属性的语义（<code>final</code> Field Semantics）</a><ul>
<li><a href="#1751-final属性的语义semantics-of-final-fields">17.5.1. final属性的语义（Semantics of <code>final</code> Fields）</a></li>
<li><a href="#1752-在构造期间读-final-属性reading-final-fields-during-construction">17.5.2. 在构造期间读 final 属性（Reading <code>final</code> Fields During Construction）</a></li>
<li><a href="#1753-final-属性的后续修改subsequent-modification-of-final-fields">17.5.3. final 属性的后续修改（Subsequent Modification of <code>final</code> Fields）</a></li>
<li><a href="#1754-写保护属性write-protected-fields">17.5.4. 写保护属性（Write-Protected Fields）</a></li>
</ul>
</li>
<li><a href="#176-字分裂word-tearing">17.6. 字分裂（Word Tearing）</a></li>
<li><a href="#177-double-和-long-的非原子处理-non-atomic-treatment-of-double-and-long">17.7. double 和 long 的非原子处理 （Non-Atomic Treatment of <code>double</code> and <code>long</code>）</a></li>
<li><a href="#references">References</a></li>
<li><a href="#结语">结语</a></li>
<li><a href="#放大招啦">放大招啦</a></li>
</ul>
<!-- tocstop -->
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在 java 中，线程由 Thread 类表示，用户创建线程的唯一方式是创建 Thread 类的一个实例，每一个线程都和这样的一个实例关联。在相应的 Thread 实例上调用 start() 方法将启动一个线程。</p>
<p>如果没有正确使用同步，线程表现出来的现象将会是令人疑惑的、违反直觉的。这个章节将描述多线程编程的语义问题，包括一系列的规则，这些规则定义了在多线程环境中线程对共享内存中值的修改是否对其他线程立即可见。java编程语言内存模型定义了统一的内存模型用于屏蔽不同的硬件架构，在没有歧义的情况下，下面将用内存模型表示这个概念。</p>
<p>这些语义没有规定多线程的程序在 JVM 的实现上应该怎么执行，而是限定了一系列规则，由 JVM 厂商来满足这些规则，即不管 JVM 的执行策略是什么，表现出来的行为必须是可被接受的。</p>
<h3 id="171-同步synchronization"><a href="#17-1-同步（synchronization）" class="headerlink" title="17.1 同步（synchronization）"></a>17.1 同步（synchronization）</h3><p>Java 提供了多种线程之间通信的机制，其中最基本的就是使用同步 (synchronization)，其使用监视器 (monitor) 来实现。java中的<strong>每个对象都关联了一个监视器</strong>，线程可以对其进行加锁和解锁操作。在同一时间，只有一个线程可以拿到对象上的监视器锁。如果其他线程在锁被占用期间试图去获取锁，那么将会被阻塞直到成功获取到锁。同时，监视器锁可以重入，也就是说如果线程 t 拿到了锁，那么线程 t 可以在解锁之前重复获取锁；每次解锁操作会反转一次加锁产生的效果。</p>
<p>synchronized 有以下两种使用方式：</p>
<ol>
<li><p>synchronized 代码块。synchronized(object) 在对某个对象上执行加锁时，会尝试在该对象的监视器上进行加锁操作，只有成功获取锁之后，线程才会继续往下执行。线程获取到了监视器锁后，将继续执行 synchronized 代码块中的代码，如果代码块执行完成，或者抛出了异常，线程将会自动对该对象上的监视器执行解锁操作。</p>
</li>
<li><p>synchronized 作用于方法，称为同步方法。同步方法被调用时，会自动执行加锁操作，只有加锁成功，方法体才会得到执行。如果被 synchronized 修饰的方法是实例方法，那么这个实例的监视器会被锁定。如果是 static 方法，线程会锁住相应的 Class 对象的监视器。方法体执行完成或者异常退出后，会自动执行解锁操作。</p>
</li>
</ol>
<p>Java语言规范既不要求阻止死锁的发生，也不要求检测到死锁的发生。如果线程要在多个对象上执行加锁操作，那么就应该使用传统的方法来避免死锁的发生，如果有必要的话，需要创建更高层次的不会产生死锁的加锁原语。（原文：Programs where threads hold (directly or indirectly) locks on multiple objects should use conventional techniques for deadlock avoidance, creating higher-level locking primitives that do not deadlock, if necessary.）</p>
<p>java 还提供了其他的一些同步机制，比如对 volatile 变量的读写、使用 java.util.concurrent 包中的同步工具类等。</p>
<blockquote>
<p><strong>同步</strong>这一节说了 Java 并发编程中最基础的 synchronized 这个关键字，大家一定要理解 synchronize 的锁是什么，它的锁是基于 Java 对象的监视器，所有任何对象都可以用来做锁。有兴趣的读者可以去了解相关知识，包括偏向锁、轻量级锁、重量级锁等。</p>
<p>小知识点：对 Class 对象加锁、对对象加锁，它们之间不构成同步。synchronized 作用于静态方法时是对 Class 对象加锁。</p>
<p>面试中经常会问到一个类中的两个 synchronized static 方法之间是否构成同步？构成同步。</p>
</blockquote>
<h3 id="172-等待集合-和-唤醒wait-sets-and-notification"><a href="#17-2-等待集合-和-唤醒（Wait-Sets-and-Notification）" class="headerlink" title="17.2 等待集合 和 唤醒（Wait Sets and Notification）"></a>17.2 等待集合 和 唤醒（Wait Sets and Notification）</h3><p>每个java对象，都关联了一个监视器，也关联了一个等待集合。等待集合是一个线程集合。</p>
<p>当对象被创建出来时，它的等待集合是空的，对于向等待集合中添加或者移除线程的操作都是原子的，以下几个操作可以操纵这个等待集合：Object.wait, Object.notify, Object.notifyAll。</p>
<p>等待集合也可能受到线程的中断状态的影响，也受到线程中处理中断的方法的影响。另外，sleep 方法和 join 方法可以感知到线程的 wait 和 notify。</p>
<blockquote>
<p>这节要讲Java线程的相关知识，主要包括：</p>
<ul>
<li>Thread中的 sleep、join、interrupt</li>
<li>继承自 Object 的 wait、notify、notifyAll</li>
<li>还有 Java 的中断，这个概念也很重要</li>
</ul>
</blockquote>
<h4 id="1721-等待-wait"><a href="#17-2-1-等待-（Wait）" class="headerlink" title="17.2.1 等待 （Wait）"></a>17.2.1 等待 （Wait）</h4><p> 等待操作由以下几个方法引发：wait()，wait(long millisecs)，wait(long millisecs, int nanosecs)。在后面两个重载方法中，如果参数为0，即wait(0)、wait(0, 0) 和wait() 是等效的。</p>
<p>如果调用 wait 方法时没有抛出 InterruptedException 异常，则表示正常返回。</p>
<p>我们在线程 t 中对对象 m 调用 m.wait() 方法，n 代表加锁编号，同时没有相匹配的解锁操作，则下面的其中之一会发生：</p>
<ul>
<li><p>如果 n 等于 0（如线程 t 没有持有对象 m 的锁），那么会抛出 IllegalMonitorStateException 异常。</p>
<blockquote>
<p>注意，如果没有获取到监视器锁，wait 方法是会抛异常的，而且注意这个异常是IllegalMonitorStateException 异常</p>
</blockquote>
</li>
<li><p>如果线程 t 调用的是 m.wait(millisecs) 或m.wait(millisecs, nanosecs)，形参 millisecs 不能为负数，nanosecs 取值应为 [0, 999999]，否则会抛出 IllegalArgumentException 异常。</p>
</li>
<li><p>如果线程 t 被中断，则抛出 InterruptedException 异常，并将中断状态设置为 false。</p>
</li>
<li><p>否则，下面的操作会顺序发生：</p>
<blockquote>
<p>注意：到这里的时候，wait 参数是正常的，同时 t 没有被中断，并且线程 t 已经拿到了 m 的监视器锁。</p>
</blockquote>
<p>1.线程 t 会加入到对象 m 的等待集合中，执行 加锁编号 n 对应的解锁操作</p>
<blockquote>
<p>这里也非常关键，前面说了，wait 方法的调用必须是线程获取到了对象的监视器锁，而这里会进行解锁操作。切记切记。。。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> Object object = <span class="keyword">new</span> Object();</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread1</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span> (object) &#123; <span class="comment">// 获取监视器锁</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            object.wait(); <span class="comment">// 这里会解锁，这里会解锁，这里会解锁</span></div><div class="line">            <span class="comment">// 顺便提一下，只是解了object上的监视器锁，如果这个线程还持有其他对象的监视器锁，这个时候是不会释放的。</span></div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            <span class="comment">// do somethings</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</blockquote>
<p>2.线程 t 不会执行任何进一步的指令，直到它从 m 的等待集合中移出。在发生以下操作的时候，线程 t 会从 m 的等待集合中移出，然后在之后的某个时间点恢复，并继续执行之后的指令。</p>
<blockquote>
<p>并不是说线程移出等待队列就马上往下执行，这个线程还需要重新获取锁，请往后看17.2.4中我写的两个简单的例子。</p>
</blockquote>
<ul>
<li><p>在 m上执行了 notify 操作，而且线程 t 被选中从等待集合中移除。</p>
</li>
<li><p>在 m 上执行了 notifyAll 操作，那么线程 t 会从等待集合中移除。</p>
</li>
<li><p>线程 t 发生了 interrupt 操作。</p>
</li>
<li><p>如果线程 t 是调用 wait(millisecs) 或者 wait(millisecs, nanosecs) 方法进入等待集合的，那么过了millisecs 毫秒或者 (millisecs*1000000+nanosecs) 纳秒后，线程t也会从等待集合中移出。</p>
</li>
<li><p>JVM 的“假唤醒”，虽然这是不鼓励的，但是这种操作是被允许的，这样 JVM 能实现将线程从等待集合中移出，而不必等待具体的移出指令。</p>
<p>注意，良好的 Java 编码习惯是，只在循环中使用 wait 方法，这个循环等待某些条件来退出循环。</p>
<blockquote>
<p>个人理解wait方法是这么用的：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">synchronized</span>(m) &#123;</div><div class="line">    <span class="keyword">while</span>(!canExit) &#123;</div><div class="line">      m.wait(<span class="number">10</span>); <span class="comment">// 等待10ms; 当然中断也是常用的</span></div><div class="line">      canExit = something();  <span class="comment">// 判断是否可以退出循环</span></div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 2个知识点：</span></div><div class="line"><span class="comment">// 1. 必须先获取到对象上的监视器锁</span></div><div class="line"><span class="comment">// 2. wait有可能被假唤醒</span></div></pre></td></tr></table></figure>
</blockquote>
<p>每个线程在一系列 可能导致它从等待集合中移出的事件 中必须决定一个顺序。这个顺序不必要和其他顺序一致，但是线程必须表现为它是按照那个顺序发生的。</p>
<p>例如，线程 t 现在在 m 的等待集合中，不管是线程 t 中断还是 m 的 notify 方法被调用，这些操作事件肯定存在一个顺序。如果线程 t 的中断先发生，那么 t 会因为 InterruptedException 异常而从 wait 方法中返回，同时 m 的等待集合中的其他线程（如果有的话）会收到这个通知。如果 m 的 notify 先发生，那么 t 会正常从 wait 方法返回，且不会改变中断状态。</p>
<blockquote>
<p>我们考虑这个场景：</p>
<p>线程 1 和线程 2 此时都 wait 了，线程 3 调用了 ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">synchronized</span> (object) &#123;</div><div class="line">	thread1.interrupt(); <span class="comment">//1</span></div><div class="line">	object.notify();  <span class="comment">//2</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以在这两条语句之间加入些代码，防止它们重排序，重排序的问题之后会说到。如果你是自己测试的话，要注意这点。</p>
<p>当方法 3 从这个同步代码块出来的时候，线程 1 是因为中断结束了 wait，线程 2 是因为 notify 结束了 wait。这里不会出现语句 2 的 notify 被作用于线程 1，即线程 1 不会既是中断又是 notify，即使在notify的时候，线程 1 还在等待的 set 中，即使线程 1 被选中来唤醒，这个 notify 一定会传递给其他的线程。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>3.线程 t 执行编号为 n 的加锁操作</p>
<p>4.如果线程 t 在 2 的时候由于中断而从 m 的等待集合中移出，那么它的中断状态会重置为 false，同时 wait 方法会抛出 InterruptedException 异常。</p>
<blockquote>
<p>这一节主要在讲线程进出等待集合的各种情况，同时，最好要知道中断是怎么用的，中断的状态重置发生于什么时候。</p>
<p>这里的 1，2，3，4 的发生顺序非常关键，大家可以仔细再看看是不是完全理解了，之后的几个小节还会更具体地阐述这个，参考代码请看 17.2.4 小节我写的简单的例子。</p>
</blockquote>
<h4 id="1722-通知notification"><a href="#17-2-2-通知（Notification）" class="headerlink" title="17.2.2 通知（Notification）"></a>17.2.2 通知（Notification）</h4><p>通知操作发生于调用 notify 和 notifyAll 方法。</p>
<p>我们在线程 t 中对对象 m 调用 m.notify()或m.notifyAll()方法，n 代表加锁编号，同时对应的解锁操作没有执行，则下面的其中之一会发生：</p>
<ul>
<li><p>如果 n 等于0，抛出 IllegalMonitorStateException 异常，因为线程 t 还没有获取到对象 m 上的锁。</p>
<blockquote>
<p>这一点很关键，只有获取到了对象上的监视器锁的线程才可以正常调用 notify</p>
</blockquote>
</li>
<li><p>如果 n 大于 0，而且这是一个 notify 操作，如果 m 的等待集合不为空，那么等待集合中的线程 u 被选中从等待集合中移出。</p>
<p>对于哪个线程会被选中而被移出，虚拟机没有提供任何保证，从等待集合中将线程 u 移出，可以让线程 u 得以恢复。注意，恢复之后的线程 u 如果对 m 进行加锁操作将不会成功，直到线程 t 完全释放锁之后。</p>
<blockquote>
<p>因为线程 t 这个时候还持有 m 的锁。这个知识点在 17.2.4 节我还会重点说。这里记住，被 notify 的线程在唤醒后是需要重新获取监视器锁的。</p>
</blockquote>
</li>
<li><p>如果 n 大于 0，而且这是一个 notifyAll 操作，那么等待集合中的所有线程都将从等待集合中移出，然后恢复。</p>
<p>注意，这些线程恢复后，只有一个线程可以锁住监视器。</p>
</li>
</ul>
<blockquote>
<p>本小节结束，通知操作相对来说还是很简单的吧。</p>
</blockquote>
<h4 id="1723-中断interruptions"><a href="#17-2-3-中断（Interruptions）" class="headerlink" title="17.2.3 中断（Interruptions）"></a>17.2.3 中断（Interruptions）</h4><p>中断发生于 Thread.interrupt 方法的调用。</p>
<p>令线程 t 调用线程 u 上的方法 u.interrupt()，其中 t 和 u 可能是相同的，这个操作会将 u 的中断状态设置为 true。</p>
<blockquote>
<p>顺便说说中断状态吧，初学者肯定以为 thread.interrupt() 方法是用来暂停线程的，主要是和它对应中文翻译的“中断”有关。中断在并发中是常用的手段，请大家一定好好掌握。可以将中断理解为线程的状态，它的特殊之处在于设置了中断状态为 true 后，这几个方法会感知到：</p>
<ol>
<li><p>wait(), wait(long), wait(long, int), join(), join(long), join(long, int), sleep(long), sleep(long, int)</p>
<p>这些方法都有一个共同之处，方法签名上都有<code>throws InterruptedException</code>，这个就是用来响应中断状态修改的。</p>
</li>
<li><p>如果线程阻塞在 InterruptibleChannel 类的 IO 操作中，那么这个 channel 会被关闭。</p>
</li>
<li><p>如果线程阻塞在一个 Selector 中，那么 select 方法会立即返回。</p>
</li>
</ol>
<p>如果线程阻塞在以上3种情况中，那么当线程感知到中断状态后，会将中断状态重新设置为 false，然后执行相应的操作。如果不是以上3种情况，那么线程中断状态就会被设置为 true。</p>
<p>当然，除了这几个方法，我知道的是 LockSupport 中的 park 方法也能自动感知到线程被中断，当然，它不会重置中断为 false。</p>
</blockquote>
<p>另外，如果有一个对象m，而且线程 u 此时在 m 的等待集合中，那么 u 将会从 m 的等待集合中移出。这会让 u 从 wait 操作中恢复过来，u 再次获取 m 的监视器锁，此时会抛出 InterruptedException 异常。</p>
<blockquote>
<p>这里的流程：设置中断 =&gt; 线程恢复 =&gt; 获取 m 的监视器锁 =&gt; 然后抛出的InterruptedException 异常</p>
<p>这个流程在前面 <strong>wait</strong> 的小节已经讲过了，这也是很多人都不了解的知识点。如果还不懂，可以看下一小节的结束，我的两个简单的例子。</p>
</blockquote>
<p>实例方法 thread.isInterrupted() 可以知道线程的中断状态。</p>
<p>调用静态方法 Thread.interrupted() 可以返回当前线程的中断状态，同时将中断状态设置为false。</p>
<blockquote>
<p>所以说，如果是这个方法调用两次，那么第二次一定会返回 false，因为第一次会重置状态。当然了，前提是中间没有发生设置线程中断状态的语句。</p>
</blockquote>
<h4 id="1724-等待-通知和中断-的交互interactions-of-waits-notification-and-interruption"><a href="#17-2-4-等待、通知和中断-的交互（Interactions-of-Waits-Notification-and-Interruption）" class="headerlink" title="17.2.4 等待、通知和中断 的交互（Interactions of Waits, Notification, and Interruption）"></a>17.2.4 等待、通知和中断 的交互（Interactions of Waits, Notification, and Interruption）</h4><p>以上的一系列规范能让我们确定 在等待、通知、中断的交互中 有关的几个属性。</p>
<p>如果一个线程在等待期间，同时发生了通知和中断，它将发生：</p>
<ul>
<li><p>从 wait 方法中正常返回，同时不改变中断状态（也就是说，调用Thread.interrupted方法将会返回true）</p>
</li>
<li><p>由于抛出了 InterruptedException 异常而从 wait 方法中返回，中断状态设置为 false</p>
</li>
</ul>
<p>线程可能没有重置它的中断状态，同时从 wait 方法中正常返回，即第一种情况。</p>
<p>同样的，通知也不能由于中断而丢失。假设 m 的等待集合为 线程集合 s，并且在另一个线程中调用了 m.notify(), 那么将发生：</p>
<ul>
<li>至少有集合 s 中的一个线程正常从 wait 方法返回，或者</li>
<li>集合 s 中的所有线程由抛出 InterruptedException 异常而返回。</li>
</ul>
<blockquote>
<p>考虑是否有这个场景：x 被设置了中断状态，notify 选中了集合中的线程 x，那么这次 notify 将唤醒线程 x，其他线程（我们假设还有其他线程在等待）不会有变化。</p>
<p>答案：不存在这种场景。这种情况下，notify 会传递给其他线程。</p>
</blockquote>
<p>注意，如果一个线程同时被中断和通知唤醒，同时这个线程通过抛出 InterruptedException 异常从 wait 中返回，那么等待集合中的某个其他线程一定会被通知。</p>
<blockquote>
<p>下面我们通过 3 个例子简单分析下 <strong>wait、notify、中断</strong> 它们的组合使用。</p>
<p>考虑以下操作：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotify</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        Object object = <span class="keyword">new</span> Object();</div><div class="line"></div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">                <span class="keyword">synchronized</span> (object) &#123;</div><div class="line">                    System.out.println(<span class="string">"线程1 获取到监视器锁"</span>);</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        object.wait();</div><div class="line">                        System.out.println(<span class="string">"线程1 恢复啦。我为什么这么久才恢复，因为notify方法虽然早就发生了，可是我还要获取锁才能继续执行。"</span>);</div><div class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                        System.out.println(<span class="string">"线程1 wait方法抛出了InterruptedException异常"</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;, <span class="string">"线程1"</span>).start();</div><div class="line"></div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">synchronized</span> (object) &#123;</div><div class="line">                    System.out.println(<span class="string">"线程2 拿到了监视器锁。为什么呢，因为线程1 在 wait 方法的时候会自动释放锁"</span>);</div><div class="line">                    System.out.println(<span class="string">"线程2 执行 notify 操作"</span>);</div><div class="line">                    object.notify();</div><div class="line">                    System.out.println(<span class="string">"线程2 执行完了 notify，先休息3秒再说。"</span>);</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        Thread.sleep(<span class="number">3000</span>);</div><div class="line">                        System.out.println(<span class="string">"线程2 休息完啦。注意了，调sleep方法和wait方法不一样，不会释放监视器锁"</span>);</div><div class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line"></div><div class="line">                    &#125;</div><div class="line">                    System.out.println(<span class="string">"线程2 休息够了，结束操作"</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;, <span class="string">"线程2"</span>).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">output：</div><div class="line">线程<span class="number">1</span> 获取到监视器锁</div><div class="line">线程<span class="number">2</span> 拿到了监视器锁。为什么呢，因为线程<span class="number">1</span> 在 wait 方法的时候会自动释放锁</div><div class="line">线程<span class="number">2</span> 执行 notify 操作</div><div class="line">线程<span class="number">2</span> 执行完了 notify，先休息<span class="number">3</span>秒再说。</div><div class="line">线程<span class="number">2</span> 休息完啦。注意了，调sleep方法和wait方法不一样，不会释放监视器锁</div><div class="line">线程<span class="number">2</span> 休息够了，结束操作</div><div class="line">线程<span class="number">1</span> 恢复啦。我为什么这么久才恢复，因为notify方法虽然早就发生了，可是我还要获取锁才能继续执行。</div></pre></td></tr></table></figure></p>
<p>同理，我们稍微修改下以上的程序，看下中断：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotify</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        Object object = <span class="keyword">new</span> Object();</div><div class="line"></div><div class="line">        Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">                <span class="keyword">synchronized</span> (object) &#123;</div><div class="line">                    System.out.println(<span class="string">"线程1 获取到监视器锁"</span>);</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        object.wait();</div><div class="line">                        System.out.println(<span class="string">"线程1 恢复啦。我为什么这么久才恢复，因为notify方法虽然早就发生了，可是我还要获取锁才能继续执行。"</span>);</div><div class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                        System.out.println(<span class="string">"线程1 wait方法抛出了InterruptedException异常，即使是异常，我也是要获取到监视器锁了才会抛出"</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;, <span class="string">"线程1"</span>);</div><div class="line">        thread1.start();</div><div class="line"></div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">synchronized</span> (object) &#123;</div><div class="line">                    System.out.println(<span class="string">"线程2 拿到了监视器锁。为什么呢，因为线程1 在 wait 方法的时候会自动释放锁"</span>);</div><div class="line">                    System.out.println(<span class="string">"线程2 设置线程1 中断"</span>);</div><div class="line">                    thread1.interrupt();</div><div class="line">                    System.out.println(<span class="string">"线程2 执行完了 中断，先休息3秒再说。"</span>);</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        Thread.sleep(<span class="number">3000</span>);</div><div class="line">                        System.out.println(<span class="string">"线程2 休息完啦。注意了，调sleep方法和wait方法不一样，不会释放监视器锁"</span>);</div><div class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line"></div><div class="line">                    &#125;</div><div class="line">                    System.out.println(<span class="string">"线程2 休息够了，结束操作"</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;, <span class="string">"线程2"</span>).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">output:</div><div class="line">线程<span class="number">1</span> 获取到监视器锁</div><div class="line">线程<span class="number">2</span> 拿到了监视器锁。为什么呢，因为线程<span class="number">1</span> 在 wait 方法的时候会自动释放锁</div><div class="line">线程<span class="number">2</span> 设置线程<span class="number">1</span> 中断</div><div class="line">线程<span class="number">2</span> 执行完了 中断，先休息<span class="number">3</span>秒再说。</div><div class="line">线程<span class="number">2</span> 休息完啦。注意了，调sleep方法和wait方法不一样，不会释放监视器锁</div><div class="line">线程<span class="number">2</span> 休息够了，结束操作</div><div class="line">线程<span class="number">1</span> wait方法抛出了InterruptedException异常，即使是异常，我也是要获取到监视器锁了才会抛出</div></pre></td></tr></table></figure></p>
<p>我们再来考虑下，之前说的 notify 和中断：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> io.github.hongjiev.learning;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by hongjie on 2017/7/7.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotify</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> a = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        Object object = <span class="keyword">new</span> Object();</div><div class="line"></div><div class="line">        WaitNotify waitNotify = <span class="keyword">new</span> WaitNotify();</div><div class="line"></div><div class="line">        Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">                <span class="keyword">synchronized</span> (object) &#123;</div><div class="line">                    System.out.println(<span class="string">"线程1 获取到监视器锁"</span>);</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        object.wait();</div><div class="line">                        System.out.println(<span class="string">"线程1 正常恢复啦。"</span>);</div><div class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                        System.out.println(<span class="string">"线程1 wait方法抛出了InterruptedException异常"</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;, <span class="string">"线程1"</span>);</div><div class="line">        thread1.start();</div><div class="line"></div><div class="line">        Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">                <span class="keyword">synchronized</span> (object) &#123;</div><div class="line">                    System.out.println(<span class="string">"线程2 获取到监视器锁"</span>);</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        object.wait();</div><div class="line">                        System.out.println(<span class="string">"线程2 正常恢复啦。"</span>);</div><div class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                        System.out.println(<span class="string">"线程2 wait方法抛出了InterruptedException异常"</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;, <span class="string">"线程2"</span>);</div><div class="line">        thread2.start();</div><div class="line"></div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">synchronized</span> (object) &#123;</div><div class="line">                    System.out.println(<span class="string">"线程3 拿到了监视器锁。"</span>);</div><div class="line">                    System.out.println(<span class="string">"线程3 设置线程1中断"</span>);</div><div class="line">                    thread1.interrupt();</div><div class="line">                    waitNotify.a = <span class="number">1</span>; <span class="comment">// 这行是为了禁止上下的两行中断和notify代码重排序</span></div><div class="line">                    System.out.println(<span class="string">"线程3 调用notify"</span>);</div><div class="line">                    object.notify();</div><div class="line">                    System.out.println(<span class="string">"线程3 调用完notify后，休息一会"</span>);</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        Thread.sleep(<span class="number">3000</span>);</div><div class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    &#125;</div><div class="line">                    System.out.println(<span class="string">"线程3 休息够了，结束同步代码块"</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;, <span class="string">"线程3"</span>).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">output:</div><div class="line">线程<span class="number">1</span> 获取到监视器锁</div><div class="line">线程<span class="number">2</span> 获取到监视器锁</div><div class="line">线程<span class="number">3</span> 拿到了监视器锁。</div><div class="line">线程<span class="number">3</span> 设置线程<span class="number">1</span>中断</div><div class="line">线程<span class="number">3</span> 调用notify</div><div class="line">线程<span class="number">3</span> 调用完notify后，休息一会</div><div class="line">线程<span class="number">3</span> 休息够了，结束同步代码块</div><div class="line">线程<span class="number">2</span> 正常恢复啦。</div><div class="line">线程<span class="number">1</span> wait方法抛出了InterruptedException异常</div></pre></td></tr></table></figure></p>
<p>这段代码反复执行，每次都会是同样的结果，不会出现 notify 被作用于线程 1 的情况。</p>
</blockquote>
<h3 id="173-休眠和礼让sleep-and-yield"><a href="#17-3-休眠和礼让（Sleep-and-Yield）" class="headerlink" title="17.3. 休眠和礼让（Sleep and Yield）"></a>17.3. 休眠和礼让（Sleep and Yield）</h3><p>Thread.sleep(millisecs) 使当前正在执行的线程休眠指定的一段时间（暂时停止执行任何指令），时间取决于参数值，精度受制于系统的定时器。<strong>休眠期间，线程不会释放任何的监视器锁</strong>。线程的恢复取决于定时器和处理器的可用性，即有可用的处理器来唤醒线程。</p>
<p>需要注意的是，Thread.sleep 和 Thread.yield 都不具有同步的语义。在 Thread.sleep 和 Thread.yield 方法调用之前，编译器不要求将寄存器中的缓存刷出到共享内存中，同时也不要求编译器在这两个方法调用之后，重新从共享内存中读取数据到缓存。</p>
<p><em>例如，我们有如下代码块，this.done 定义为一个 non-volatile 的属性，初始值为 false。</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (!<span class="keyword">this</span>.done)</div><div class="line">    Thread.sleep(<span class="number">1000</span>);</div></pre></td></tr></table></figure>
<p><em>编译器可以只读取一次 this.done 到缓存中，然后一直使用缓存中的值，也就是说，这个循环可能永远不会结束，即使是有其他线程将 this.done 的值修改为 true。</em></p>
<blockquote>
<p>yield 是告诉操作系统的调度器：我的cpu可以先让给其他线程。注意，调度器可以不理会这个信息。这个方法几乎没用。</p>
</blockquote>
<h3 id="174-内存模型memory-model"><a href="#17-4-内存模型（Memory-Model）" class="headerlink" title="17.4 内存模型（Memory Model）"></a>17.4 内存模型（Memory Model）</h3><blockquote>
<p>内存模型这一节比较长，请耐心阅读</p>
</blockquote>
<p>内存模型描述的是程序的执行过程中对数据的读写是否是按照程序的规则正确执行的。java内存模型定义了一系列规则，这些规则定义了对共享内存的写操作对于读操作的可见性。</p>
<blockquote>
<p>简单地说，定义内存模型，主要就是为了规范多线程程序中修改或者访问同一个值的时候的行为。</p>
</blockquote>
<p>内存模型描述了程序执行时的可能的表现行为。只要执行的结果是满足java内存模型的所有规则，那么虚拟机对于具体的实现可以自由发挥。</p>
<blockquote>
<p>从侧面说，不管虚拟机的实现是怎么样的，多线程程序的执行结果都应该是可预测的。</p>
</blockquote>
<p><em>虚拟机实现者可以自由地执行大量的代码转换，包括重排序操作和删除一些不必要的同步。</em></p>
<blockquote>
<p>这里我画了一条线，从这条线到下一条线之间是两个重排序的例子，如果你没接触过，可以看一下，如果你已经熟悉了或者在其他地方看过了，请直接往下滑</p>
</blockquote>
<hr>
<p><strong>示例 17.4-1 不正确的同步可能导致奇怪的结果</strong></p>
<p>java语言允许编译器和微处理器对执行指令进行重排序，导致我们会经常看到似是而非的现象。</p>
<p>如表17.4-A中所示，A和B是共享属性，r1 和 r2 是局部变量。初始时，另 A == B == 0。</p>
<p><strong>表17.4-A. 重排序导致奇怪的结果 - 原始代码</strong></p>
<table>
<thead>
<tr>
<th>Thread 1</th>
<th>Thread 2</th>
</tr>
</thead>
<tbody>
<tr>
<td>1: <code>r2 = A;</code></td>
<td>3: <code>r1 = B;</code></td>
</tr>
<tr>
<td>2: <code>B = 1;</code></td>
<td>4: <code>A = 2;</code></td>
</tr>
</tbody>
</table>
<p>按照我们的直觉来说，r2 == 2 同时 r1 == 1 应该是不可能的。直观地说，指令1和3应该是最先执行的。如果指令1最先执行，那么它应该不会看到指令4对A的写入操作。如果指令3最先执行，那么它应该不会看到执行2对B的写入操作。</p>
<p>如果真的表现出了 r2==2 和r1==1，那么我们应该知道，指令4先于指令1执行了，</p>
<p>如果在执行过程出表现出这种行为（ r2==2 和r1==1），那么我们可以推断出以下指令依次执行：指令4=&gt;指令1=&gt;指令2=&gt;指令3。看上去，这种顺序是荒谬的。</p>
<p>但是，java是允许编译器对指令进行重排序的，只要保证在单线程的情况下，能保证程序是按照我们想要的结果进行执行，即编译器可以对单线程内不产生数据依赖的语句之间进行重排序。如果指令1和指令2发生了重排序，如按照表17.4-B所示的顺序进行执行，那么我们就很容易看到，r2==2 和r1==1是可能发生的。</p>
<p><strong>表 17.4-B. 重排序导致奇怪的结果 - 允许的编译器转换</strong></p>
<table>
<thead>
<tr>
<th>Thread 1</th>
<th>Thread 2</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>B = 1;</code></td>
<td><code>r1 = B;</code></td>
</tr>
<tr>
<td><code>r2 = A;</code></td>
<td><code>A = 2;</code></td>
</tr>
</tbody>
</table>
<blockquote>
<p>B = 1;  <strong>=&gt;</strong>  r1 = B;  <strong>=&gt;</strong>  A = 2;  <strong>=&gt;</strong>  r2 = A;</p>
</blockquote>
<p>对于很多程序员来说，这个结果看上去是broken的，但是这段代码是没有正确的同步导致的：</p>
<ul>
<li>其中有一个线程执行了写操作</li>
<li>另一个线程对同一个属性执行了读操作</li>
<li>同时，读操作和写操作没有使用同步来确定它们之间的执行顺序</li>
</ul>
<blockquote>
<p>简单地说，之后要讲的一大堆东西主要就是为了确定共享内存读写的执行顺序，不正确或者说非法的代码就是因为读写同一内存地址没有使用同步（这里不仅仅只是说synchronized），从而导致执行的结果具有不确定性。</p>
</blockquote>
<p>这个是<strong>数据竞争(data race)</strong>的一个例子。当代码包含数据竞争时，经常会发生违反我们直觉的结果。</p>
<p>有几个机制会导致表17.4-B中的指令重排序。java的JIT编译器实现可能会重排序代码，或者处理器也会做重排序操作。此外，java虚拟机实现中的内存层次结构也会使代码像重排序一样。在本章中，我们将所有会导致代码重排序的机制称为compiler。</p>
<p>另一个可能产生奇怪的结果的示例如表17.4-C，初始时 p == q 同时 p.x == 0。这个代码也是没有正确使用同步的；在这些写入共享内存的写操作中，没有进行强制的先后排序。</p>
<p><strong>Table 17.4-C</strong></p>
<table>
<thead>
<tr>
<th>Thread 1</th>
<th>Thread 2</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>r1 = p;</code></td>
<td><code>r6 = p;</code></td>
</tr>
<tr>
<td><code>r2 = r1.x;</code></td>
<td><code>r6.x = 3;</code></td>
</tr>
<tr>
<td><code>r3 = q;</code></td>
<td></td>
</tr>
<tr>
<td><code>r4 = r3.x;</code></td>
<td></td>
</tr>
<tr>
<td><code>r5 = r1.x;</code></td>
</tr>
</tbody>
</table>
<p>一个简单的编译器优化操作是会复用r2的结果给r5，因为它们都是读取 r1.x，而且在单线程语义中，r2 到 r5之间没有其他的相关的写入操作，这种情况如表17.4-D所示。</p>
<p><strong>Table 17.4-D</strong></p>
<table>
<thead>
<tr>
<th>Thread 1</th>
<th>Thread 2</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>r1 = p;</code></td>
<td><code>r6 = p;</code></td>
</tr>
<tr>
<td><code>r2 = r1.x;</code></td>
<td><code>r6.x = 3;</code></td>
</tr>
<tr>
<td><code>r3 = q;</code></td>
<td></td>
</tr>
<tr>
<td><code>r4 = r3.x;</code></td>
<td></td>
</tr>
<tr>
<td><span style="color: red">r5 = r2;</span></td>
</tr>
</tbody>
</table>
<p>现在，我们来考虑一种情况，在线程1第一次读取r1.x 和r3.x之间，线程2执行r6=p; r6.x=3; 编译器进行了r5复用r2结果的优化操作，那么r2==r5==0，r4 == 3，从程序员的角度来看，p.x的值由0变为3，然后又变为0。</p>
<blockquote>
<p>我简单整理了一下：</p>
</blockquote>
<table>
<thead>
<tr>
<th>Thread 1</th>
<th>Thread 2</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>r1 = p;</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>r2 = r1.x;</code></td>
<td></td>
<td>r2 == 0</td>
</tr>
<tr>
<td></td>
<td><code>r6 = p;</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>r6.x = 3;</code></td>
<td></td>
</tr>
<tr>
<td><code>r3 = q;</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>r4 = r3.x;</code></td>
<td></td>
<td>r4 == 3</td>
</tr>
<tr>
<td><code>r5 = r2;</code></td>
<td></td>
<td>r5 == r2 == 0</td>
</tr>
</tbody>
</table>
<hr>
<blockquote>
<p>例子结束，回到正题</p>
</blockquote>
<p>java内存模型定义了在程序的每一步，哪些值是内存可见的。对于隔离的每个线程来说，其操作是由我们线程中的语义来决定的，但是读操作是由内存模型来控制的。当我们提到这点时，我们说程序遵守<code>线程内语义</code>，线程内语义说的是单线程内的语义，它允许我们基于线程内读操作看到的值完全预测线程的行为。如果我们要确定线程 t 中的操作是否是合法的，我们只要评估当线程 t 在单线程环境中运行时是否是合法的就可以，如该规范的其余部分所定义的。</p>
<blockquote>
<p>这段话不太好理解，首先记住“线程内语义”这个概念，之后还会用到。我对这段话的理解是，在单线程中，我们是可以通过一行一行看代码来预测执行结果的，只不过，代码中使用到的读取内存的值我们是不能确定的，这取决于在内存模型这个大框架下，我们的程序会读到的值。也许是最新的值，也许是过时的值，取决于我们的代码实现。</p>
</blockquote>
<p>此节描述除了 final 关键字外的<code>java内存模型</code>的规范，final将在之后的17.5节介绍。</p>
<p><em>这里描述的内存模型并不是基于 Java编程语言的面向对象。为了简洁起见，我们经常展示没有类或方法定义的代码片段。 大多数示例包含两个或多个线程，其中包含局部变量，共享全局变量或对象的实例字段的语句。 我们通常使用诸如 r1 或 r2 之类的变量名来表示方法或线程本地的变量。 其他线程无法访问此类变量。</em></p>
<h4 id="1741-共享变量shared-variables"><a href="#17-4-1-共享变量（Shared-Variables）" class="headerlink" title="17.4.1. 共享变量（Shared Variables）"></a>17.4.1. 共享变量（Shared Variables）</h4><p>所有线程都可以访问到的内存称为<code>共享内存</code>或<code>堆内存</code>。</p>
<p>所有的实例属性，静态属性，还有数组的元素都存储在堆内存中。在本章中，我们用术语<code>变量</code>来表示这些元素。</p>
<p>局部变量、方法参数、异常对象，它们不会在线程间共享，也不会受到内存模型定义的任何影响。</p>
<p>两个线程对同一个变量同时进行<code>读-写操作</code>或<code>写-写操作</code>，我们称之为“冲突”。</p>
<blockquote>
<p>好，这一节都是废话，愉快地进入到下一节</p>
</blockquote>
<h4 id="1742-操作actions"><a href="#17-4-2-操作（Actions）" class="headerlink" title="17.4.2. 操作（Actions）"></a>17.4.2. 操作（Actions）</h4><p><code>线程间操作</code>是指由一个线程执行的动作，可以被另一个线程检测到或直接影响到。以下是几种可能发生的<code>线程间操作</code>：</p>
<ul>
<li><p>读 （普通变量，非volatile）。读一个变量。</p>
</li>
<li><p>写 （普通变量，非volatile）。写一个变量。</p>
</li>
<li><p>同步操作，如下：</p>
<ul>
<li><p>volatile读。读一个volatile变量</p>
</li>
<li><p>volatile写。写入一个volatile变量</p>
</li>
<li><p>加锁。对一个对象的监视器加锁。</p>
</li>
<li><p>解锁。解除对某个对象的监视器锁。</p>
</li>
<li><p>线程的第一个和最后一个操作。</p>
</li>
<li><p>开启线程操作，或检测一个线程是否已经结束。</p>
</li>
</ul>
</li>
<li><p><code>外部操作</code>。一个外部操作指的是可被观察到的在外部执行的操作，同时它的执行结果受外部环境控制。</p>
</li>
<li><p><code>线程分歧操作</code>。此操作只由处于无限循环的线程执行，在该循环中不执行任何内存操作、同步操作、或外部操作。如果一个线程执行了分歧操作，那么其后将跟着无数的分歧操作。</p>
<p>分歧操作的引入是为了用来说明，线程可能会导致其他所有线程停顿而不能继续执行。</p>
</li>
</ul>
<p>此规范仅关心线程间操作，我们不关心线程内部的操作（比如将两个局部变量的值相加存到第三个局部变量中）。如前文所说，所有的线程都需要遵守线程内语义。对于线程间操作，我们经常会简单地称为<strong>操作</strong>。</p>
<p>我们用元祖&lt; <em>t</em>, <em>k</em>, <em>v</em>, <em>u</em> &gt;来描述一个操作：</p>
<ul>
<li><p><strong>t</strong> - 执行操作的线程</p>
</li>
<li><p><strong>k</strong> - 操作的类型。</p>
</li>
<li><p><strong>v</strong> - 操作涉及的变量或监视器</p>
<p>对于加锁操作，v是被锁住的监视器；对于解锁操作，v是被解锁的监视器。</p>
<p>如果是一个读操作（volatile读或非volatile读），v是读操作对应的变量</p>
<p>如果是一个写操作(volatile写或非volatile写)，v是写操作对应的变量</p>
</li>
<li><p><strong>u</strong> - 该操作的任意的唯一的标识符</p>
</li>
</ul>
<p>外部动作元组还包含一个附加组件，其中包含由执行操作的线程感知的外部操作的结果。 这可能是关于操作的成败的信息，以及操作中所读的任何值。</p>
<p>外部操作的参数（如哪些字节写入哪个socket）不是外部操作元祖的一部分。这些参数是通过线程中的其他操作进行设置的，并可以通过检查线程内语义进行确定。它们在内存模型中没有被明确讨论。</p>
<p>在非终结执行中，不是所有的外部操作都是可观察的。17.4.9小节讨论非终结执行和可观察操作。</p>
<blockquote>
<p>大家看完这节最懵逼的应该是<code>外部操作</code>和<code>线程分歧操作</code>，我简单解释下。</p>
<p>外部操作大家可以理解为 Java 调用了一个 native 的方法，Java可以得到这个 native 方法的返回值，但是对于具体的执行其实不感知的，意味着 Java 其实不能对这种语句进行重排序，因为 Java 无法知道方法体会执行哪些指令。</p>
<p>引用 stackoverflow 中的一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// method()方法中jni()是外部操作，不会和 "foo = 42;" 这条语句进行重排序。</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Externalization</span> </span>&#123; </div><div class="line">  <span class="keyword">int</span> foo = <span class="number">0</span>; </div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123; </div><div class="line">    jni(); <span class="comment">// 外部操作</span></div><div class="line">    foo = <span class="number">42</span>; </div><div class="line">  &#125; </div><div class="line">  <span class="function"><span class="keyword">native</span> <span class="keyword">void</span> <span class="title">jni</span><span class="params">()</span></span>; <span class="comment">/* &#123; </span></div><div class="line">    assert foo == 0; //我们假设外部操作执行的是这个。</div><div class="line">  &#125; */ </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再来个线程分歧操作的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 线程分歧操作阻止了重排序，所以 "foo = 42;" 这条语句不会先执行</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadDivergence</span> </span>&#123; </div><div class="line">  <span class="keyword">int</span> foo = <span class="number">0</span>; </div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">thread1</span><span class="params">()</span> </span>&#123; </div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;&#125; <span class="comment">// 线程分歧操作</span></div><div class="line">    foo = <span class="number">42</span>; </div><div class="line">  &#125; </div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">thread2</span><span class="params">()</span> </span>&#123; </div><div class="line">    <span class="keyword">assert</span> foo == <span class="number">0</span>; </div><div class="line">  &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="1743-程序和程序顺序programs-and-program-order"><a href="#17-4-3-程序和程序顺序（Programs-and-Program-Order）" class="headerlink" title="17.4.3. 程序和程序顺序（Programs and Program Order）"></a>17.4.3. 程序和程序顺序（Programs and Program Order）</h4><p>在每个线程 t 执行的所有线程间动作中，t 的程序顺序是反映 <strong>根据t的线程内语义执行这些动作的顺序</strong> 的总顺序。</p>
<p>如果所有操作的执行顺序 和 代码中的顺序一致，那么一组操作就是<code>连续一致</code>的，并且，对变量v的每个读操作 r 会看到写操作 w 写入的值，也就是：</p>
<ul>
<li><p>写操作 w 先于 读操作 r 完成，并且</p>
</li>
<li><p>没有其他的写操作 w’ 使得 w’ 在 w 之后 r 之前发生。</p>
</li>
</ul>
<p><code>连续一致性</code>对于可见性和程序执行顺序是一个非常强的保证。在这种场景下，所有的单个操作（比如读和写）构成一个统一的执行顺序，这个执行顺序和代码出现的顺序是一致的，同时每个单个操作都是原子的，且对所有线程来说立即可见。</p>
<p>如果程序没有任何的数据竞争，那么程序的所有执行操作将表现为连续一致。</p>
<p>Sequential consistency and/or freedom from data races still allows errors arising from groups of operations that need to be perceived atomically and are not.</p>
<p><code>连续一致性</code> 和/或 数据竞争的自由仍然允许错误从一组操作中产生。</p>
<blockquote>
<p>完全不知道这句话是什么意思</p>
</blockquote>
<p><em>如果我们用连续一致性作为我们的内存模型，那我们讨论的许多关于编译器优化和处理器优化就是非法的。比如在17.4-C中，一旦执行 p.x=3，那么后续对于该位置的读操作应该是立即可以读到最新值的。</em></p>
<blockquote>
<p><strong>连续一致性</strong>的核心在于每一步的操作都是原子的，同时对于所有线程都是可见的，而且不存在重排序。所以，Java内存模型肯定不会采用这种策略，因为它直接限制了编译器和 JVM 的各种优化措施。</p>
<p>注意：很多地方所说的<strong>顺序一致性</strong>就是这里的<strong>连续一致性</strong>，英文是 <strong>Sequential consistency</strong></p>
</blockquote>
<h4 id="1744-同步顺序synchronization-order"><a href="#17-4-4-同步顺序（Synchronization-Order）" class="headerlink" title="17.4.4. 同步顺序（Synchronization Order）"></a>17.4.4. 同步顺序（Synchronization Order）</h4><p>每个执行都有一个同步顺序。同步顺序是由执行过程中的每个同步操作组成的顺序。对于每个线程 t，同步操作组成的同步顺序是和线程 t 中的代码顺序一致的。</p>
<p>同步操作包括了如下同步关系：</p>
<ul>
<li><p>对于监视器 m 的解锁与所有后续操作对于 m 的加锁同步</p>
</li>
<li><p>对 volatile 变量 v 的写入，与所有其他线程后续对 v 的读同步</p>
</li>
<li><p>启动线程的操作与线程中的第一个操作同步。</p>
</li>
<li><p>对于每个属性写入默认值（0， false，null）与每个线程对其进行的操作同步。</p>
<p>尽管在创建对象完成之前对对象属性写入默认值有点奇怪，但从概念上来说，每个对象都是在程序启动时用默认值初始化来创建的。</p>
</li>
<li><p>线程 T1 的最后操作与线程 T2 发现线程 T1 已经终结同步。</p>
<p>线程 T2 可以通过 T1.isAlive() 或 T1.join() 方法来判断 T1 是否已经终结。</p>
</li>
<li><p>如果线程 T1 中断了 T2，那么线程 T1 的中断操作与其他所有线程发现 T2 被中断了同步（通过抛出 InterruptedException 异常，或者调用 Thread.interrupted 或 Thread.isInterrupted ）</p>
</li>
</ul>
<p>以上同步顺序可以理解为对于某资源的释放先于其他操作对同一资源的获取。</p>
<blockquote>
<p>好，这节相对easy，说的就是关于 <strong>A synchronizes-with B</strong> 的一系列规则。</p>
</blockquote>
<h4 id="1745-happens-before顺序happens-before-order"><a href="#17-4-5-Happens-before顺序（Happens-before-Order）" class="headerlink" title="17.4.5. Happens-before顺序（Happens-before Order）"></a>17.4.5. Happens-before顺序（Happens-before Order）</h4><blockquote>
<p>这一节我自己的理解有限，我尽量将原文直译过来。想要了解更深的东西，你可能还需要查询更多的其他资料。</p>
</blockquote>
<p>两个操作可以用happens-before来确定它们的执行顺序，如果一个操作 happens-before 于另一个操作，那么我们说第一个操作对于第二个操作是可见的。</p>
<blockquote>
<p>注意：happens-before 强调的是可见性问题</p>
</blockquote>
<p>如果我们分别有操作x和操作y，我们写成 <strong>hb(x, y)</strong> 来表示<strong>x happens-before y</strong>。</p>
<ul>
<li><p>如果操作x和操作y是同一个线程的两个操作，并且在代码上操作x先于操作y出现，那么有hb(x, y)</p>
<blockquote>
<p>请注意，这里不代表不可以重排序，只要没有数据依赖关系，重排序就是可能的。</p>
<p>这里的 x，y 既然有 hb(x, y) 的关系，说明它们两个操作之间存在数据依赖关系。</p>
</blockquote>
</li>
<li><p>对象构造方法的最后一行指令 happens-before 于 finalizer 方法的第一行指令。</p>
</li>
<li><p>如果操作 x 与随后的操作 y 构成同步，那么 hb(x, y)。</p>
<blockquote>
<p>这里说的就是上一小节的同步顺序</p>
</blockquote>
</li>
<li><p>hb(x, y) 和 hb(y, z)，那么可以推断出 hb(x, z)</p>
</li>
</ul>
<p>对象的wait方法关联了加锁和解锁的操作，它们的 happens-before 关系即是加锁 happens-before 解锁。</p>
<p>我们应该注意到，两个操作之间的 happens-before 的关系并不一定表示它们在 JVM 的具体实现上必须是这个顺序，如果重排序后的操作结果和合法的执行结果是一致的，那么这种实现就不是非法的。</p>
<p>比如说，在线程中对对象的每个属性写入初始默认值并不需要先于线程的开始，只要这个事实没有被读到就可以了。</p>
<blockquote>
<p>我们可以发现，happens-before 规则主要还是上一节 <strong>同步顺序</strong> 中的规则，加上额外的几条</p>
</blockquote>
<p>More specifically, if two actions share a <em>happens-before</em> relationship, they do not necessarily have to appear to have happened in that order to any code with which they do not share a <em>happens-before</em> relationship. Writes in one thread that are in a data race with reads in another thread may, for example, appear to occur out of order to those reads.</p>
<p>更具体地说，如果两个操作是 happens-before 的关系，但是在它们没有 happens-before 关系的地方，它们之间没有必要还是按照这个顺序执行。例如，与一个线程中的读操作进行数据竞争的另一个线程中的写操作会对这些读操作表现为次序颠倒。</p>
<blockquote>
<p>我没懂具体什么意思</p>
</blockquote>
<p>happens-before关系用于定义当发生数据竞争的时候。</p>
<p>A set of synchronization edges, <em>S</em>, is <em>sufficient</em> if it is the minimal set such that the transitive closure of <em>S</em> with the program order determines all of the <em>happens-before</em> edges in the execution. This set is unique.</p>
<blockquote>
<p>没懂</p>
</blockquote>
<p>从上述定义可以得出：</p>
<ul>
<li><p>对一个监视器的解锁操作happens-before于后续的对这个监视器的加锁操作。</p>
<blockquote>
<p>注意，这里说了内存可见性的问题，解锁之前对于共享变量的修改，对于后续加锁的线程是可见的</p>
</blockquote>
</li>
<li><p>对volatile属性的写操作先于后续对这个属性的读操作。</p>
</li>
<li><p>线程的start()先于任何在线程中定义的语句。</p>
</li>
<li><p>如果A线程中调用了B.join()，那么B线程中的操作先于A线程join()返回之后的任何语句。</p>
</li>
<li><p>对象的默认初始值happens-before于程序中对它的其他操作。</p>
</li>
</ul>
<p>当程序出现两个没有happens-before关系的操作对同一数据进行访问时，我们称之为程序中有数据竞争。</p>
<p>除了线程间操作，数据竞争不直接影响其他操作的语义，如读取数组的长度、检查转换的执行、虚拟方法的调用。</p>
<p>因此，数据竞争不会导致错误的行为，例如为数组返回错误的长度。</p>
<p>当且仅当所有连续一致的操作都没有数据争用时，程序就是<strong>正确同步</strong>的。</p>
<p>如果一个程序是正确同步的，那么程序中的所有操作就会表现出连续一致性。</p>
<p>这是一个对于程序员来说强有力的保证，程序员不需要知道重排序的原因，就可以确定他们的代码是否包含数据争用。因此，他们不需要知道重排序的原因，来确定他们的代码是否是正确同步的。一旦确定了代码是正确同步的，程序员也就不需要担心重排序对于代码的影响。</p>
<blockquote>
<p>其实就是正确同步的代码不存在数据竞争，这个时候程序员不需要关心重排序是否会影响我们的代码。</p>
</blockquote>
<p>程序必须正确同步，以避免当出现重排序时，会出现一系列的奇怪的行为。正确同步的使用，不能保证程序的全部行为都是正确的。但是，它的使用可以让程序员以很简单的方式就能知道可能发生的行为。正确同步的程序表现出来的行为更不会依赖于可能的重排序。没有使用正确同步，非常奇怪、令人疑惑、违反直觉的任何行为都是可能的。</p>
<p>我们说，对变量 v 的读操作 r 能看到对 v 的写操作 w，如果: </p>
<ul>
<li>读操作 r 不是先于 w 发生（比如不是hb(r, w)），同时</li>
<li>没有写操作 w’ 穿插在 w 和 r 中间。</li>
</ul>
<blockquote>
<p>下面是关于<strong>Happens-before Consistency</strong>的部分，我自己也没懂什么意思，就不做过多解释了。</p>
<p>下面是关于<strong>Happens-before Consistency</strong>的部分，我自己也没懂什么意思，就不做过多解释了。</p>
<p>下面是关于<strong>Happens-before Consistency</strong>的部分，我自己也没懂什么意思，就不做过多解释了。</p>
</blockquote>
<p>Informally, a read <em>r</em> is allowed to see the result of a write <em>w</em> if there is no <em>happens-before</em> ordering to prevent that read.</p>
<p>非正式地，如果没有happens-before关系阻止读操作r，那么读操作r就能看到写操作w的结果。</p>
<p>A set of actions <em>A</em> is <em>happens-before consistent</em> if for all reads <em>r</em> in <em>A</em>, where <em>W(r)</em> is the write action seen by <em>r</em>, it is not the case that either <em>hb(r, W(r))</em> or that there exists a write <em>w</em> in <em>A</em> such that <em>w.v</em> = <em>r.v</em> and <em>hb(W(r), w)</em> and <em>hb(w, r)</em>.</p>
<p>操作集合A是 <strong>happens-before consistent</strong>：要么存在hb(r, W(r))，读操作r，W(r) 是对于读操作r可见的写操作；要么存在A中的写操作w满足 w.v = r.v，hb(W(r), w)，hb(w, r)。</p>
<p>In a <em>happens-before consistent</em> set of actions, each read sees a write that it is allowed to see by the <em>happens-before</em> ordering.</p>
<p>在<strong>happens-before consistent</strong>操作集合中，每个读操作都可以看到 通过happens-before顺序规定的 允许看到的写入。</p>
<hr>
<p><strong>Example 17.4.5-1. Happens-before Consistency</strong></p>
<p>For the trace in <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.4.5-A" target="_blank" rel="external">Table 17.4.5-A</a>, initially <code>A == B == 0</code>. The trace can observe <code>r2 == 0</code> and <code>r1 == 0</code> and still be <em>happens-before consistent</em>, since there are execution orders that allow each read to see the appropriate write.</p>
<p><strong>Table 17.4.5-A. Behavior allowed by happens-before consistency, but not sequential consistency.</strong></p>
<table>
<thead>
<tr>
<th>Thread 1</th>
<th>Thread 2</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>B = 1;</code></td>
<td><code>A = 2;</code></td>
</tr>
<tr>
<td><code>r2 = A;</code></td>
<td><code>r1 = B;</code></td>
</tr>
</tbody>
</table>
<p>Since there is no synchronization, each read can see either the write of the initial value or the write by the other thread. An execution order that displays this behavior is:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1: B = 1;</div><div class="line">3: A = 2;</div><div class="line">2: r2 = A;  // sees initial write of 0</div><div class="line">4: r1 = B;  // sees initial write of 0</div></pre></td></tr></table></figure>
<p>Another execution order that is happens-before consistent is:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1: r2 = A;  // sees write of A = 2</div><div class="line">3: r1 = B;  // sees write of B = 1</div><div class="line">2: B = 1;</div><div class="line">4: A = 2;</div></pre></td></tr></table></figure>
<p>In this execution, the reads see writes that occur later in the execution order. This may seem counterintuitive, but is allowed by <em>happens-before</em> consistency. Allowing reads to see later writes can sometimes produce unacceptable behaviors.</p>
<hr>
<blockquote>
<p>关于后面的几个小节，我自己对其理解不够，也不希望误导大家，如果大家感兴趣的话，请参阅其他资料。</p>
</blockquote>
<h4 id="1746-executions"><a href="#17-4-6-Executions" class="headerlink" title="17.4.6. Executions"></a>17.4.6. Executions</h4><blockquote>
<p>未完成</p>
</blockquote>
<h4 id="1747-well-formed-executions"><a href="#17-4-7-Well-Formed-Executions" class="headerlink" title="17.4.7. Well-Formed Executions"></a>17.4.7. Well-Formed Executions</h4><blockquote>
<p>未完成</p>
</blockquote>
<h4 id="1748-executions-and-causality-requirements"><a href="#17-4-8-Executions-and-Causality-Requirements" class="headerlink" title="17.4.8. Executions and Causality Requirements"></a>17.4.8. Executions and Causality Requirements</h4><blockquote>
<p>未完成</p>
</blockquote>
<h4 id="1749-observable-behavior-and-nonterminating-executions"><a href="#17-4-9-Observable-Behavior-and-Nonterminating-Executions" class="headerlink" title="17.4.9. Observable Behavior and Nonterminating Executions"></a>17.4.9. Observable Behavior and Nonterminating Executions</h4><blockquote>
<p>未完成</p>
</blockquote>
<h3 id="175-final-属性的语义final-field-semantics"><a href="#17-5-final-属性的语义（final-Field-Semantics）" class="headerlink" title="17.5. final 属性的语义（final Field Semantics）"></a>17.5. final 属性的语义（<code>final</code> Field Semantics）</h3><p>用final声明的属性正常情况下初始化一次后，就不会被改变。final属性的语义与普通属性的语义有一些不一样。尤其是，编译器可以跨同步屏障移动 final 属性的读以及对任意或未知方法的调用。相应地，编译器被允许保存<strong>缓存在寄存器中的final属性的值</strong>，而不是像普通属性一样从内存中重新读取。</p>
<p>final属性同时也允许程序员不需要使用同步就可以实现<strong>线程安全</strong>的<strong>不可变对象</strong>。一个线程安全的不可变对象对于所有线程来说都是不可变的，即使传递这个对象的引用时存在数据竞争。这可以提供安全的保证，即使是错误的或者恶意的对于这个不可变对象的使用。final 属性必须被正确地使用以用来提供不可变性的保证。</p>
<p>对象只有在构造方法结束了才被认为<code>完全初始化</code>了。一个线程如果需要引用了一个对象，那么这个对象必须被完全初始化后才对此线程可见，这保证了线程只能看到这个对象的已经正确初始化的 final 属性。</p>
<p>final属性的使用模型是非常简单的：在对象的构造方法中设置 final 属性；同时在对象初始化完成前，不要将此对象的引用写入到其他线程可以访问到的地方。如果这个条件满足，当其他线程看到这个对象的时候，那个线程始终可以看到正确初始化后的对象的 final 属性。同时，它也可以看到 final 属性引用的<strong>与 final 属性一样新的</strong>对象或数组。</p>
<blockquote>
<p>这里面说到了一个<strong>正确初始化</strong>的问题，看过《Java并发编程实战》的可能对这个会有印象，不要在构造方法中将 this 发布出去。</p>
</blockquote>
<hr>
<p><strong>Example 17.5-1. final Fields In The Java Memory Model</strong></p>
<p>这段代码把final属性和普通属性进行对比。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FinalFieldExample</span> </span>&#123; </div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> x;</div><div class="line">    <span class="keyword">int</span> y; </div><div class="line">    <span class="keyword">static</span> FinalFieldExample f;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinalFieldExample</span><span class="params">()</span> </span>&#123;</div><div class="line">        x = <span class="number">3</span>; </div><div class="line">        y = <span class="number">4</span>; </div><div class="line">    &#125; </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</div><div class="line">        f = <span class="keyword">new</span> FinalFieldExample();</div><div class="line">    &#125; </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (f != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">int</span> i = f.x;  <span class="comment">// 程序一定能得到 3  </span></div><div class="line">            <span class="keyword">int</span> j = f.y;  <span class="comment">// 也许会看到 0</span></div><div class="line">        &#125; </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个类<code>FinalFieldExample</code>有一个 final 属性 x 和一个普通属性 y。可能有一个线程执行 writer() 方法，另一个线程执行 reader() 方法。</p>
<p>因为 writer() 方法在对象完全构造后将引用写入 f，那么 reader() 方法将一定可以看到初始化后的 f.x : 将读到一个 int 值 3。然而， f.y 不是 final 的，所以程序不能保证可以看到 4，可能会得到 0。</p>
<hr>
<hr>
<p><strong>Example 17.5-2. final Fields For Security</strong></p>
<p>final属性被设计成用来保障很多操作的安全性。考虑以下代码，线程1执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Global.s = &quot;/tmp/usr&quot;.substring(4);</div></pre></td></tr></table></figure>
<p>同时，线程2执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String myS = Global.s; </div><div class="line">if (myS.equals(&quot;/tmp&quot;))System.out.println(myS);</div></pre></td></tr></table></figure>
<p><strong>String</strong> 对象是不可变对象，同时 string 操作不需要使用同步。虽然 String 的实现没有任何的数据竞争，但是其他使用到 String 对象的代码可能是存在数据竞争的，内存模型没有对存在数据竞争的代码提供安全性保证。特别是，如果 String 类中的属性不是 final 的，那么有可能（虽然不太可能）线程 2 会看到这个 string 对象的 offset 为初始值 0，那么就会出现myS.equals(“/tmp”)。之后的一个操作可能会看到这个 String 对象的正确的 offset 值 4，那么会得到 “/usr”。Java 中的许多安全特性都依赖于 String 对象的不可变性，即使是恶意代码在数据竞争的环境中在线程之间传递 String 对象的引用。</p>
<blockquote>
<p>大家看这段的时候，如果要看代码，请注意，这里说的是  JDK6 及以前的 String 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span>  </span></div><div class="line">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span>  </div><div class="line">&#123;  </div><div class="line">    <span class="comment">/** The value is used for character storage. */</span>  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];  </div><div class="line">  </div><div class="line">    <span class="comment">/** The offset is the first index of the storage that is used. */</span>  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> offset;  </div><div class="line">  </div><div class="line">    <span class="comment">/** The count is the number of characters in the String. */</span>  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> count;  </div><div class="line">  </div><div class="line">    <span class="comment">/** Cache the hash code for the string */</span>  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></div></pre></td></tr></table></figure>
<p>因为到 JDK7 和 JDK8 的时候，代码已经变为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></div><div class="line">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> &#123;</div><div class="line">    <span class="comment">/** The value is used for character storage. */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</div><div class="line"></div><div class="line">    <span class="comment">/** Cache the hash code for the string */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></div><div class="line"></div><div class="line">    <span class="comment">/** use serialVersionUID from JDK 1.0.2 for interoperability */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6849794470754667710L</span>;</div></pre></td></tr></table></figure>
</blockquote>
<hr>
<h4 id="1751-final属性的语义semantics-of-final-fields"><a href="#17-5-1-final属性的语义（Semantics-of-final-Fields）" class="headerlink" title="17.5.1. final属性的语义（Semantics of final Fields）"></a>17.5.1. final属性的语义（Semantics of <code>final</code> Fields）</h4><p>令 o 为一个对象，c 为 o 的构造方法，构造方法中对 final 的属性 f 进行写入值。当构造方法 c 退出的时候，会在final 属性 f 上执行一个 freeze 操作。</p>
<p>注意，如果一个构造方法调用了另一个构造方法，在被调用的构造方法中设置 final 属性，那么对于 final 属性的 freeze 操作发生于被调用的构造方法结束的时候。</p>
<blockquote>
<p>我没懂这边的 freeze 操作是什么。</p>
</blockquote>
<p>对于每一个执行，读操作的行为被其他的两个偏序影响，解引用链 <em>dereferences()</em> 和内存链 <em>mc()</em>，它们被认为是执行的一部分。这些偏序必须满足下面的约束：</p>
<blockquote>
<p>我对于解引用链和内存链完全不熟悉，所以下面这段我就不翻译了。</p>
</blockquote>
<ul>
<li><p>Dereference Chain: If an action <em>a</em> is a read or write of a field or element of an object <em>o</em> by a thread <em>t</em> that did not initialize <em>o</em>, then there must exist some read <em>r</em> by thread <em>t</em> that sees the address of <em>o</em> such that <em>r</em> <em>dereferences(r, a)</em>.</p>
</li>
<li><p>Memory Chain: There are several constraints on the memory chain ordering:</p>
<ul>
<li>If <em>r</em> is a read that sees a write <em>w</em>, then it must be the case that <em>mc(w, r)</em>.</li>
<li>If <em>r</em> and <em>a</em> are actions such that <em>dereferences(r, a)</em>, then it must be the case that <em>mc(r, a)</em>.</li>
<li>If <em>w</em> is a write of the address of an object <em>o</em> by a thread <em>t</em> that did not initialize <em>o</em>, then there must exist some read <em>r</em> by thread <em>t</em> that sees the address of <em>o</em> such that <em>mc(r, w)</em>.</li>
</ul>
</li>
</ul>
<p>Given a write <em>w</em>, a freeze <em>f</em>, an action <em>a</em> (that is not a read of a <code>final</code> field), a read <em>r1</em> of the <code>final</code> field frozen by <em>f</em>, and a read <em>r2</em> such that <em>hb(w, f)</em>, <em>hb(f, a)</em>, <em>mc(a, r1)</em>, and <em>dereferences(r1, r2)</em>, then when determining which values can be seen by <em>r2</em>, we consider <em>hb(w, r2)</em>. (This <em>happens-before</em> ordering does not transitively close with other <em>happens-before</em> orderings.)</p>
<p>Note that the <em>dereferences</em> order is reflexive, and <em>r1</em> can be the same as <em>r2</em>.</p>
<p>For reads of <code>final</code> fields, the only writes that are deemed to come before the read of the <code>final</code> field are the ones derived through the <code>final</code> field semantics.</p>
<h4 id="1752-在构造期间读-final-属性reading-final-fields-during-construction"><a href="#17-5-2-在构造期间读-final-属性（Reading-final-Fields-During-Construction）" class="headerlink" title="17.5.2. 在构造期间读 final 属性（Reading final Fields During Construction）"></a>17.5.2. 在构造期间读 final 属性（Reading <code>final</code> Fields During Construction）</h4><p>在构造对象的线程中，对该对象的 final 属性的读操作，遵守正常的 happens-before 规则。如果在构造方法内，读某个 final 属性晚于对这个属性的写操作，那么这个读操作可以看到这个 final 属性已经被定义的值，否则就会看到默认值。</p>
<h4 id="1753-final-属性的后续修改subsequent-modification-of-final-fields"><a href="#17-5-3-final-属性的后续修改（Subsequent-Modification-of-final-Fields）" class="headerlink" title="17.5.3. final 属性的后续修改（Subsequent Modification of final Fields）"></a>17.5.3. final 属性的后续修改（Subsequent Modification of <code>final</code> Fields）</h4><p>在许多场景下，如反序列化，系统需要在对象构造之后改变 final 属性的值。final 属性可以通过反射和其他与具体实现相关的方式来改变。唯一的具有合理语义的模式是：对象被构造出来，然后对象中 final 属性被更新。这个对象不应该被其他线程看到，直到对于这个对象的 final 属性的所有更新操作都已经完成。对于 final 属性的 freeze 操作发生于构造方法的结束，这个时候 final 属性已经被设值，还有通过反射或其他具体的机制对于 final 属性的更新之后。</p>
<p>即使是这样，依然存在几个难点。如果一个 final 属性在属性声明的时候初始化为一个常量表达式，对于这个 final 属性的改变也许是不可见的，因为对于这个 final 属性的使用是在编译时用常量表达式来替换的。</p>
<p>另一个问题是，该规范允许对 final 属性的强制优化。在线程中，允许对于 final 属性的读操作与构造方法之外的对于这个 final 属性的修改进行重排序。</p>
<hr>
<p><strong>Example 17.5.3-1. 对于 final 属性的强制优化（Aggressive Optimization of final Fields</strong>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> x;</div><div class="line">    A() &#123; </div><div class="line">        x = <span class="number">1</span>; </div><div class="line">    &#125; </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123; </div><div class="line">        <span class="keyword">return</span> d(<span class="keyword">this</span>,<span class="keyword">this</span>); </div><div class="line">    &#125; </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">d</span><span class="params">(A a1, A a2)</span> </span>&#123; </div><div class="line">        <span class="keyword">int</span> i = a1.x; </div><div class="line">        g(a1); </div><div class="line">        <span class="keyword">int</span> j = a2.x; </div><div class="line">        <span class="keyword">return</span> j - i; </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">(A a)</span> </span>&#123; </div><div class="line">    	<span class="comment">// 利用反射将 a.x 的值修改为 2</span></div><div class="line">        <span class="comment">// uses reflection to change a.x to 2 </span></div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在方法 d 中，编译器允许对 x 的读操作和方法 g 进行重排序，这样的话，<code>new A().f()</code>可能会返回 -1, 0, 或 1。</p>
<hr>
<blockquote>
<p>下文将说到一个比较少见的 <strong>final-field-safe context</strong></p>
</blockquote>
<p>JVM实现可以提供一种方式在 <strong>final 属性安全上下文</strong>（final-field-safe context）中执行代码块。如果一个对象是在 <em>final 属性安全上下文</em>中构造出来的，那么在这个<em>final 属性安全上下文</em>中对于 final 属性的读操作不会和相应的对于 final 属性的修改进行重排序。</p>
<p><em>final 属性安全上下文</em>还提供了另一个保护。如果一个线程已经看到一个不正确的已经发布的一个对象的引用，并且这个对象允许线程看到 final 属性的默认值，然后，在 <em>final 属性安全上下文</em>中读取对象的正确发布的引用，这可以保证看到正确的 final 属性的值。在形式上，在<em>final 属性安全上下文</em>中执行的代码被认为是一个独立的线程（仅用于满足 final 属性的语义）。</p>
<p>在实现中，编译器不应该将对 final 属性的访问移入或移出<em>final 属性安全上下文</em>（尽管它可以在这个执行上下文的周边移动，只要这个对象没有在这个上下文中进行构造）。</p>
<p>对于 <em>final 属性安全上下文</em>的使用，一个恰当的地方是执行器或者说线程池。在独立的<em>final 属性安全上下文</em>中执行每一个 <code>Runnable</code>，执行器可以保证在一个 <code>Runnable</code> 中对对象o的不正确的访问不会移除 final 属性对于同一执行器内的其他 <code>Runnable</code> 的保证。</p>
<h4 id="1754-写保护属性write-protected-fields"><a href="#17-5-4-写保护属性（Write-Protected-Fields）" class="headerlink" title="17.5.4. 写保护属性（Write-Protected Fields）"></a>17.5.4. 写保护属性（Write-Protected Fields）</h4><p>通常，如果一个属性是 <code>final</code> 的和 <code>static</code> 的，那么这个属性是不会被改变的。但是， <code>System.in</code>, <code>System.out</code>, 和 <code>System.err</code> 是 <code>static final</code> 的，出于遗留的历史原因，它们必须允许被 <code>System.setIn</code>, <code>System.setOut</code>, 和 <code>System.setErr</code> 这几个方法改变。我们称这些属性是<strong>写保护</strong>的，用以区分普通的 final 属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> InputStream in = <span class="keyword">null</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> PrintStream out = <span class="keyword">null</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> PrintStream err = <span class="keyword">null</span>;</div></pre></td></tr></table></figure>
<p>编译器需要将这些属性与 final 属性区别对待。例如，普通 final 属性的读操作对于同步是“免疫的”：对于锁或 volatile 关联的内存屏障的读操作不会影响到对于 final 属性的读操作读到的值。因为写保护属性的值是可以被改变的，所以同步事件应该对它们有影响。因此，语义规定这些属性被当做普通属性，不能被用户的代码改变，除非是 <code>System</code>类中的代码。</p>
<blockquote>
<p>中间的 final 属性的读操作对同步免疫 我也没看懂。</p>
</blockquote>
<h3 id="176-字分裂word-tearing"><a href="#17-6-字分裂（Word-Tearing）" class="headerlink" title="17.6. 字分裂（Word Tearing）"></a>17.6. 字分裂（Word Tearing）</h3><p>实现Java虚拟机需要考虑的一件事情是，每个对象属性以及数组元素之间是独立的，更新一个属性或元素不能影响其他属性或元素的读取与更新。尤其是，两个线程在分别更新byte数组相邻的元素时，不能互相影响与干扰，且不需要同步来保证连续一致性。</p>
<p>一些处理器不提供写入单个字节的能力。 通过简单地读取整个字，更新相应的字节，然后将整个字写入内存，用这种方式在这种处理器上实现字节数组更新是非法的。 这个问题有时被称为字分裂（word tearing），在这种不能单独更新单个字节的处理器上，将需要寻求其他的方法。</p>
<blockquote>
<p>请注意，对于大部分处理器来说，都没有这个问题</p>
</blockquote>
<hr>
<p><strong>Example 17.6-1. Detection of Word Tearing</strong></p>
<p>以下程序用于测试是否存在字分裂：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordTearing</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LENGTH = <span class="number">8</span>;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ITERS = <span class="number">1000000</span>;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">byte</span>[] counts = <span class="keyword">new</span> <span class="keyword">byte</span>[LENGTH];</div><div class="line">    <span class="keyword">static</span> Thread[] threads = <span class="keyword">new</span> Thread[LENGTH];</div><div class="line"></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> id;</div><div class="line"></div><div class="line">    WordTearing(<span class="keyword">int</span> i) &#123;</div><div class="line">        id = i;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">byte</span> v = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ITERS; i++) &#123;</div><div class="line">            <span class="keyword">byte</span> v2 = counts[id];</div><div class="line">            <span class="keyword">if</span> (v != v2) &#123;</div><div class="line">                System.err.println(<span class="string">"Word-Tearing found: "</span> +</div><div class="line">                        <span class="string">"counts["</span> + id + <span class="string">"] = "</span> + v2 +</div><div class="line">                        <span class="string">", should be "</span> + v);</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            v++;</div><div class="line">            counts[id] = v;</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"done"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LENGTH; ++i)</div><div class="line">            (threads[i] = <span class="keyword">new</span> WordTearing(i)).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这表明写入字节时不得覆写相邻的字节。</p>
<hr>
<h3 id="177-double-和-long-的非原子处理-non-atomic-treatment-of-double-and-long"><a href="#17-7-double-和-long-的非原子处理-（Non-Atomic-Treatment-of-double-and-long）" class="headerlink" title="17.7. double 和 long 的非原子处理 （Non-Atomic Treatment of double and long）"></a>17.7. double 和 long 的非原子处理 （Non-Atomic Treatment of <code>double</code> and <code>long</code>）</h3><p>在Java内存模型中，对于 non-volatile 的 long 或 double 值的写入是通过两个单独的写操作完成的：long 和 double 是64位的，被分为两个32位来进行写入。那么可能就会导致一个线程看到了某个操作的低32位的写入和另一个操作的高32位的写入。</p>
<p>写入或者读取 volatile 的 long 和 double 值是原子的。</p>
<p>写入和读取对象引用一定是原子的，不管具体实现是32位还是64位。</p>
<p>将一个64位的 long 或 double 值的写入分为相邻的两个32位的写入对于JVM的实现来说是很方便的。为了性能上的考虑，JVM的实现是可以决定采用原子写入还是分为两个部分写入的。</p>
<p>如果可能的话，我们鼓励JVM的实现避开将64位值的写入分拆成两个操作。我们也希望程序员将共享的64位值操作设置为 volatile 或者使用正确的同步，这样可以提供更好的兼容性。</p>
<blockquote>
<p>目前来看，几乎所有的虚拟机实现对于 long 和 double 的写入都是原子的。</p>
</blockquote>
<p>（全文完）</p>
<h3 id="references"><a href="#References" class="headerlink" title="References"></a>References</h3><p><strong>官方原文</strong>：<a href="https://docs.oracle.com/javase/specs/" target="_blank" rel="external">https://docs.oracle.com/javase/specs/</a></p>
<p><strong>JSR 133 (Java Memory Model) FAQ</strong>: <a href="http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html" target="_blank" rel="external">http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html</a></p>
<p><strong>The JSR-133 Cookbook for Compiler Writers</strong>： <a href="http://gee.cs.oswego.edu/dl/jmm/cookbook.html" target="_blank" rel="external">http://gee.cs.oswego.edu/dl/jmm/cookbook.html</a></p>
<blockquote>
<p>这是 Doug Lea 大神写的，属于更深层次的实现上的解读了，如果大家有需要的话，我后续也许可以整理整理。</p>
</blockquote>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>路还很长，如果有机会，我会在其中挑出一些 topic 出来和大家分享我自己的理解。</p>
<h3 id="放大招啦"><a href="#放大招啦" class="headerlink" title="放大招啦"></a>放大招啦</h3><p><img src="/images/shang.jpg" alt=""></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/06/16/AbstractQueuedSynchronizer/" rel="next" title="一行一行源码分析清楚AbstractQueuedSynchronizer">
                <i class="fa fa-chevron-left"></i> 一行一行源码分析清楚AbstractQueuedSynchronizer
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/07/20/AbstractQueuedSynchronizer-2/" rel="prev" title="一行一行源码分析清楚 AbstractQueuedSynchronizer (二)">
                一行一行源码分析清楚 AbstractQueuedSynchronizer (二) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="Hong Jie" />
          <p class="site-author-name" itemprop="name">Hong Jie</p>
           
              <p class="site-description motion-element" itemprop="description">coding is coding.</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#171-同步synchronization"><span class="nav-number">2.</span> <span class="nav-text">17.1 同步（synchronization）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#172-等待集合-和-唤醒wait-sets-and-notification"><span class="nav-number">3.</span> <span class="nav-text">17.2 等待集合 和 唤醒（Wait Sets and Notification）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1721-等待-wait"><span class="nav-number">3.1.</span> <span class="nav-text">17.2.1 等待 （Wait）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1722-通知notification"><span class="nav-number">3.2.</span> <span class="nav-text">17.2.2 通知（Notification）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1723-中断interruptions"><span class="nav-number">3.3.</span> <span class="nav-text">17.2.3 中断（Interruptions）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1724-等待-通知和中断-的交互interactions-of-waits-notification-and-interruption"><span class="nav-number">3.4.</span> <span class="nav-text">17.2.4 等待、通知和中断 的交互（Interactions of Waits, Notification, and Interruption）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#173-休眠和礼让sleep-and-yield"><span class="nav-number">4.</span> <span class="nav-text">17.3. 休眠和礼让（Sleep and Yield）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#174-内存模型memory-model"><span class="nav-number">5.</span> <span class="nav-text">17.4 内存模型（Memory Model）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1741-共享变量shared-variables"><span class="nav-number">5.1.</span> <span class="nav-text">17.4.1. 共享变量（Shared Variables）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1742-操作actions"><span class="nav-number">5.2.</span> <span class="nav-text">17.4.2. 操作（Actions）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1743-程序和程序顺序programs-and-program-order"><span class="nav-number">5.3.</span> <span class="nav-text">17.4.3. 程序和程序顺序（Programs and Program Order）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1744-同步顺序synchronization-order"><span class="nav-number">5.4.</span> <span class="nav-text">17.4.4. 同步顺序（Synchronization Order）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1745-happens-before顺序happens-before-order"><span class="nav-number">5.5.</span> <span class="nav-text">17.4.5. Happens-before顺序（Happens-before Order）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1746-executions"><span class="nav-number">5.6.</span> <span class="nav-text">17.4.6. Executions</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1747-well-formed-executions"><span class="nav-number">5.7.</span> <span class="nav-text">17.4.7. Well-Formed Executions</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1748-executions-and-causality-requirements"><span class="nav-number">5.8.</span> <span class="nav-text">17.4.8. Executions and Causality Requirements</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1749-observable-behavior-and-nonterminating-executions"><span class="nav-number">5.9.</span> <span class="nav-text">17.4.9. Observable Behavior and Nonterminating Executions</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#175-final-属性的语义final-field-semantics"><span class="nav-number">6.</span> <span class="nav-text">17.5. final 属性的语义（final Field Semantics）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1751-final属性的语义semantics-of-final-fields"><span class="nav-number">6.1.</span> <span class="nav-text">17.5.1. final属性的语义（Semantics of final Fields）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1752-在构造期间读-final-属性reading-final-fields-during-construction"><span class="nav-number">6.2.</span> <span class="nav-text">17.5.2. 在构造期间读 final 属性（Reading final Fields During Construction）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1753-final-属性的后续修改subsequent-modification-of-final-fields"><span class="nav-number">6.3.</span> <span class="nav-text">17.5.3. final 属性的后续修改（Subsequent Modification of final Fields）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1754-写保护属性write-protected-fields"><span class="nav-number">6.4.</span> <span class="nav-text">17.5.4. 写保护属性（Write-Protected Fields）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#176-字分裂word-tearing"><span class="nav-number">7.</span> <span class="nav-text">17.6. 字分裂（Word Tearing）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#177-double-和-long-的非原子处理-non-atomic-treatment-of-double-and-long"><span class="nav-number">8.</span> <span class="nav-text">17.7. double 和 long 的非原子处理 （Non-Atomic Treatment of double and long）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#references"><span class="nav-number">9.</span> <span class="nav-text">References</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结语"><span class="nav-number">10.</span> <span class="nav-text">结语</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#放大招啦"><span class="nav-number">11.</span> <span class="nav-text">放大招啦</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hong Jie</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  

    
      <script id="dsq-count-scr" src="https://javaxiong.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://yoursite.com/2017/07/05/Threads-And-Locks-md/';
          this.page.identifier = '2017/07/05/Threads-And-Locks-md/';
          this.page.title = '深入分析 java 8 编程语言规范：Threads and Locks';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://javaxiong.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  





  








  





  

  

  

  

  

  

</body>
</html>
